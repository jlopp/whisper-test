I am basically going to go over some ways that I've been thinking about basically hardening lightning network, in terms of making security better and making the client more scalable itself, and then I'll talk about some issues and pain points that come up when you're doing fees on mainnet. And there's going to be some relatively minor changes that I propose to Bitcoin in this talk. We'll have to see if they have a chance of getting in. They are not big sweeping changes. One is a new sighash type and one is a new opcode and then there's covenants but that's an entirely separate story itsef of course.

Talk overview
A quick overview first. I am going to give an overview of lightning's security model. I am not going to go much into lightning's overview because I kind of assume that you at least vaguely know what lightning network is. Payment channels, you connect them, you can route across them and that's the jist of it. We're going to talk about hardening the contract breach event. Some of you have talked about ways that we can do that in terms of addin more consensus changes, or going at it from the point of view of a stratey when a breach actually happens and there's a large mempool backlog. Then, I am going to introduce a new lightning channel type and a new channel design. Basically making the channels more succinct, meaning you'd have to store less history and things like making outsourcing a lot more efficient as well. And then I am going to talk about kind of like outsourcing and a newer model and a model that assumes that-- that maintains client privacy as much as possible, because if you want this to scale in the outsourcing to support a large number of clients then we want them to store as little state as possible. And then we're going to go into making lightning more succinct on chain. If it's an off-chain protocol, then we want to make sure it has the smallest on-chain footprint possible, otherwise it's not really scaling because you're hitting the chain every single time. It should be off-chain itself.

Security model
There's a diagram of the layers of lightning over here. People always say it's like "layer 2". But to me there's a lot more layers on top of that. To me, layer 1 is bitcoin and the blockchain itself. Layer 2 is the link layer between channels. This is basically how do I open a channel between myself and Bob and how do Bob and I actually update the channels. Then there's end-to-end routing and the HTLCs and onion routing and whatever else is involved there. And then you have an application layer for things being built on top of lightning, such as exchanges.

I had emojis on this slide, but I guess it didn't translate somehow. That's okay.

The way that lightning works is that it uses bitcoin or another blockchain as a dispute-mediation system. Instead of having every transaction go on bitcoin itself, we do contract creation on bitcoin itself. We can do enforcement there. But the execution is off-chain. We do the initialization on the blockchain, then we do the execution on the side off of the chain. This makes it succinct and that's fine. We treat the chain as a trust anchor. Basically the way it works is that any time that we have a dispute, we can go to the blockchain with our evidence and transactions and then we can publish these transactions more broadly and we can show that hey my counterparty is defrauding me he is violating some clause of the lightning smart contract. And then I get all my money back, basically.

We have the easy way and the hard way. Optimistically, we can do everything off-chain. If we want to exit the contract, then we do signatures between each other and it goes to the chain. The hard way is in the case where I have to go on-chain to actually do a property dispute because of a violation in the contract. When we're handling disputes, the way we think about it is that we can write to the chain "eventually". This is configured by a time parameter called T which is like a bip112 CSV value. It means that every time someone goes to the chain there's a contestation period that is open for time period T to basically refute their claim. We say "eventually" because T can be configured. You want to configure "T" based on the size of the channel. If it's a $10 channel then maybe you want a few hours, and if it's a million dollar channel then maybe you want T to be closer to a month or whatever.

The other thing we assume is that miners or pool operators are not colluding against us. They could censor all of our transactions on the chain. As part of this assumption, we assume a certain minimum level of decentralization of the blockchain miners because otherwise you can get blacklisted or something. There are ways that you could try to make the channels blend in with everything else and all of the other transactions occurring on the blockchain, and there's some cool work on that front too.

Strategy: Hardening contract breach defense
Moving on, let's talk about hardening contract breach defense strategy. Something that comes up a lot and people ask this is, how do I handle contract breach in the case of massive backlog? This would be the case where, for whatever reason, my fees are sky high, someone is spamming the chain and there's a contract breach. What am I going to do from there on? There's some things that people have worked on for adding new consensus changes to bitcoin, such as the timelock would stop after the block was ever so full or possibly you would have some pre-allocated arena where you could do battle for your smart contract. This is looking from a bit more strategic standpoint and looking at the dynamics on the fees in terms of handling the commitment transaction itself.

Whenever someone tries to broadcast a prior state, perhaps out of order, they are basically locked to that particular state. Bob basically had $2 on the newest state and he had $10 on the other state. He's going to go back to the $10 state. At that point, Bob can only access just his money from the channel itself. Bob revoked some of the outputs. What his counterparty can do is basically start to progressively siphon Bob fees basically into miner fees. This is now a situation where there's some strategy there because Bob has two options: he can either stop, or I can keep going and I'm eventually going to siphon all of his money to miner's fees. The only way that his will actually succeed to get that prior state transaction into the chain is if he pays more in miner's fees than he actually has in his balance himself. You can either do that by using child-pays-for-parent. I think this is a pretty good approach. What we're doing here is that the justice transaction is going to be using replace-by-fee, we're going to use that to progressively bump up and the fees the money of the cheater basically into the fees. I think this is a pretty good stopgap for the way things work right now. If you have someone that can be malicious at all, you can almost always penalize this person. So even if there's a massive backlog, assuming that the miner wants the higher fee rate, then well you know Bob basically gets nothing. This adds further incentive from actually, people trying to do cheating, because now there is this strategy where basically I can just give away your money to miner's fees and the adversary gets nothing. I'm still made whole through this entire ideal, so whatever happens I'm okay, I want to penalize and punish Bob in the worst way possible and I'm going to jump into the queue in front of everything else in the mempool. I could have put maybe 20 BTC towards fees- I'm fine, I'm just punishing my counterparty, it's scorched earth, and then I wash my hands and walk away and everything's okay.

Reducing client side history storage
https://www.youtube.com/watch?v=V3f4yYVCxpk&t=5m45s

Now we're going to talk about scaling lightning itself. Basically, from the client side. The way it works is that because contract execution is local, we have a local transcript. Every time we do a new state update, there's basically a shadow chain, and by shadow chain I mean that we have a "blockchain" in the sense that each state refers to previous state in a particular way but also we can do state transitions between these states themselves. The shadow chain is only manifested on the chain in the case of a contract breach or if I just want to force-close. Typically in the normal case we do a cooperative close which is where both sides sign a multisig, we go on chain, you see nothing else. The shadow chain is only manifested on the blockchain in the case of a breakdown or some sort of breach remedy situation.

These state transitions in the channel can be very generic, later this year we might get fancier with some cool stuff. Right now it's just adding HTLCs, removing HTLCs, and keeping track of prior state. The goal here is to reduce the amount of state that the client needs to keep track of. It would be good if they could keep track of less state, because then they could have more high-throughput transactions. It has implications for outsourcing too. If the state requirements for the client to actually act on the contract is reduced, then it makes the outsourcers more succinct as well, and if the outsourcers are more succinct then people are going to run them and if people run them then we're going to have more security so it's a reasonable goal to pursue this.

Overview of commitment invalidation
Before we get into reducing amount of state, I am going to talk about some of the history of how to do commitment invalidation on lightning. You have a series of states. You walk forward in these states one-by-one. Each time you go to a new state, you revoke the old one. You move from state 1, you revoke it, state 2 revoked now you're on state 3. The central question to how do we channels is how do we do invalidation. One thing to note is that this only matters fo bi-directional channels where you're going both ways. If it's a uni-directional channel, every single state update I do is basically benefiting the other participant in some way and they don't really have incentive to go back on the prior states, but if you have a bi-directional channel there's probably some point in the history where one of the two counterparties was better off, where they had some incentive to try to cheat and try to go back to that prior state. We solve this by invalidating every single state once we make a new state. The penalty here is that if I ever catch you broadcasting a prior state then you basically get slashed, your money all goes away and there's some strategy there which I have already talked about a bit. Naievely, you keep all the prior states. But that's not very good because now you have this linearly growing storage as you do these updates. People like lightning and other off-chain protocols because they can be super fast, but if you have to store a new state for every single update then that's not very good. The other thing is that, say you're going to the blockchain to close-out the prior state but that's not very good because now you have control transactions going into the chain which isn't really good if you're trying to make everything succinct itself.

History of succinct commitment invalidation
So let's get intothe history of and how we currently do commitment invalidation.

When one of the first bi-directional channels was proposed, it was basically a bip68 mechanism with decrementing sequence locks. Use relative timelocks such that atest states can go in before the prior states. The drawback was that this had a limit on the number of possible state updates. bip68 is basically this relative timelock mechanismn. You'd start with 30 day timelock, do an update, go to 29 days, then do an update, then it's 28. The way that this enforced latest state was by you could only broadcast latest state using the timelocks. If you had state 30 then I'm going to broadcast state 28 before you can broadcast that because the timelock isn't going to be expired yet. The drawback is that this has a limited number of possible updates, like if it's a 30 day locktime then with a 1-day period that's only 30 updates at most. You have to bake that into the lifetime of the channel.

Moving on, there was another proposal called a commitment invalidation tree, which is used in duplex payment channels (cdecker). You keep the decrementing timelock thing, but then you add another layer on top of this which is basically a tree layer. Because of the way that timelocks work, you could only ever broadcast-- you can't broadcast the leaf until you broadcast the root itself. So basically it also because they were bidirectional channels they had to be reset periodically. They were constructed using two uni-directional channels and when the balances got out of whack then you had to reset that. Every time you reset it, you had to decrement the timelock, and then every time you do that you had to measure this root thing, and that worked out pretty well because that would let you, with a tweak, call the kick-off transaction and then you have an indefinite lifetime channel. Pretty cool, but the drawback is that you have this additional off-chain footprint. If you had this massive tree that you needed to broadcast, to get to your certain state, then it's not very succinct because you have to broadcast all of those transactions, which is not particularly good if our goal is succinctness.

What lightning does now is called commitment revocations (hash or key based). Must reveal secret of prior state when accepting new state. The drawback is that you must critically store order log n of remote party, more complex key derivation, and there's asymmetric state. We use commitment revocations where, the way it works, every single state has a public key and when you transition to the next state you basically must give up that private key. It's a little more complex than that. The cool part of this is that we had figured out a way to generate the public key in a deterministic way. The client constantly has a state and there's this tree type, choose a random number generator, generate all these secrets, and you as the receiver can collapse all of these down into basically the particular states themselves.

The goal here is to develop a commitment scheme with symmetric state. Commitment revocations in lightning right now have asymmetric state. This is basically due to the way we ascribe-- we know what our transactions look like, if you broadcast mine on chain then I already have what I need. But that can get worrisome like multiparty channels... if we could make them symmetric, then multiparty channels wouldn't have this weird combinatorial state blowup, and also we could basically make all of the state much smaller itself.

Commitment invalidation in lightning v1.0
So here's a review of basically of the way we do commitment invalidation in lightning right now. Well, I put v1.1 on the slide. But we're on v1.0, I don't know. I guess I was thinking ahead. The way that it works is that every single state has this thing called a "commitment point", which is just like a EC base point. The way we derive each of the private keys for each of these points is using a shachain. You can think of a shachain as having a key k and you have an index i which gives you random element in i, and me as a receiver because of this particular structure I can collapse them. Any time I have a shachain element 10 I can forget everything else and re-derive the data by only knowing the shachain 10 were the parameters, more or less.

We do this key derivation scheme which is like kind of complex-ish but important to takeaway here that when we do the state update, you give me a public key, and then I do some elliptic curve math where it turns out that once I reveal the private key to this thing, then only you can actually sign for that state. We make one of these commimtent points, and one of the revocation points, and when we go to the next state then you basically reveal that to me and that's how it works.

This one has a few drawbacks. It gets involved because we were trying kind of defend against rogue key attacks and things like that. But I think we can make this simpler. The client storage has to store the current state and this log k state, and it's log k where k is actualy the number of state updates ever. The outsourcer needs a signature for every single state and in addition to that needs a signature for any other HTLC we have and it basically needs to collapse the log k state itself. So we need to make this simpler and more succinct.

OP_CHECKSIGFROMSTACK
https://www.youtube.com/watch?v=V3f4yYVCxpk&t=12m15s

And now for a brief diversion.

I am proposing an addition to bitcoin called OP_CHECKSIGFROMSTACK. Bitcoin checks signatures. You have lots of checksigs when you're validating the blockchain itself. One thing about bitcoin is that, it's always assumed to be this thing called the sighash. Any time there's a signature operation, implicitly we generate this thing called the sighash which is derived from the transaction itself. It's a heuristic function where you can control what is actually being signed itself. That's cool, but it's a little bit restrictive. What if we could add the ability to validate signatures on arbitrary messages? This is super powerful because it can let you do things like delegation, have someone's public key if it's signed then take this output. We could also use this to make oracles, like an integer signed by Bitfinex and we could use this inside of a smart contract. We could also do things like having these "blessed" message structures where your protocol has a message that might be opaque but has a particular structure and it can only be signed by both participants. So you could sign this at some point in the future and use this as evidence some point later on.

This proposal isn't particularly soft-fork safe for bitcoin yet. But basically you have message, signature, public key, and maybe a version and different versions in the future. Or we could have ECDSA or Schnorr signatures or whatever else. The opcode would tell you if it's valid or whatever.

Signed sequence commitments
Now on to a new commitment invalidation method. This is something I call signed sequence commitments. Rather than now us using this revocation model, what we do is every single state has a state number. We then commit to that state number, and then we sign the commitment. That signed commitment goes into the script itself. This is cool because we have this random number R so when you're looking at the script you don't know which state we're on. To do revocation, we could say, if you can open this commitment itself and because it's signed you can't forge it because it's a 2-of-2 multisig, so we can open the commitment and then show me another commitment with an R sequence value that is greater than the one in this commitment and that means that there was some point in history where two of you cooperated but then one of the counterparties went back to this prior state and tried to cheat. So this is a little bit of a simpler construction. We have a signed sequence number, you can prove a new sequence number, and we can prove it because we hide the state of it, because it can be the case that when we go to the chain we don't necessarily want to reveal how many state updates we've actually done.

Signing is pretty simple: you have this number R which we can derive from some deterministic method. We increment the state number. We have c, which is the commitment. The signature is important, it's actually an aggregate signature. It's the signature between both of us. There's a few techniques for this, like two-party ECDSA multiparty computation techniques, there's some signature aggregation stuff you could do, just somehow you collaborate and make a signature and it works.
